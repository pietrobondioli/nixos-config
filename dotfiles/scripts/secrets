#!/usr/bin/zsh

# Discover command locations at script start
OP_CMD=$(command -v op)
MKTEMP_CMD=$(command -v mktemp)
RM_CMD=$(command -v rm)

# Validate required commands exist
if [[ -z "$OP_CMD" ]]; then
    echo "‚ùå ERROR: 1Password CLI (op) is not installed or not in PATH." >&2
    echo "   Install from: https://developer.1password.com/docs/cli/get-started/" >&2
    return 1
fi

# Helper function to run in the background
parallel_op_read() {
    local secret_path=$1
    local var_name=$2

    local secret_value=$("$OP_CMD" read "$secret_path" 2>/dev/null)
    echo "export $var_name=\"$secret_value\""
}

load_secrets() {
    # Suppress job control notifications for cleaner output
    setopt LOCAL_OPTIONS NO_NOTIFY NO_MONITOR

    # ============================================================================
    # CONFIGURATION: Add your secrets here as "secret_path|var_name" pairs
    # ============================================================================
    local SECRETS=(
        "op://Personal/pietro-pc-github-token/token|GITHUB_TOKEN"
        "op://Personal/pietro-pc-github-token/token|GITHUB_REGISTRY_AUTH_TOKEN"
        "op://Personal/syniti-fort-awesome-token/token|FONT_AWESOME_TOKEN"
        "op://Personal/syniti-nexus/username|NEXUS_USERNAME"
        "op://Personal/syniti-nexus/password|NEXUS_PASSWORD"
        "op://Personal/syniti-nexus/dotnet-source|NEXUS_DOTNET_SOURCE"
        "op://Personal/syniti-skp-nuget/dotnet-source|SKP_DOTNET_SOURCE"
    )
    # ============================================================================

    echo "üîë Step 1: Checking 1Password connection..."

    # Better authentication check
    if ! "$OP_CMD" whoami >/dev/null 2>&1; then
        echo "‚ùå ERROR: Not signed in to 1Password CLI." >&2

        echo "   Running op signin..."
        "$OP_CMD" signin < /dev/tty

        if ! "$OP_CMD" whoami >/dev/null 2>&1; then
            echo "‚ùå ERROR: Signin failed. Please check your credentials." >&2
            return 1
        fi
    fi

    # Test first secret access
    local first_entry="${SECRETS[1]}"
    local auth_path="${first_entry%%|*}"
    if ! "$OP_CMD" read "$auth_path" >/dev/null 2>&1; then
        echo "‚ùå ERROR: Cannot access secret. Check vault name and item path." >&2
        return 1
    fi
    echo "‚úÖ 1Password connection established. Moving to parallel fetch."

    # Parallel Fetching Setup
    local TEMP_ASSIGNMENTS=$("$MKTEMP_CMD")

    # Launch background jobs for each secret
    for secret_entry in "${SECRETS[@]}"; do
        local secret_path="${secret_entry%%|*}"
        local var_name="${secret_entry##*|}"

        parallel_op_read "$secret_path" "$var_name" >> "$TEMP_ASSIGNMENTS" &
    done

    # Wait for all background processes to finish
    echo "‚è≥ Step 2: Waiting for all secrets to load in parallel..."
    wait

    # Import Variables into Current Shell
    source "$TEMP_ASSIGNMENTS"

    # Clean up the temporary file
    "$RM_CMD" "$TEMP_ASSIGNMENTS"

    echo "‚ú® All secrets loaded and exported."
}
